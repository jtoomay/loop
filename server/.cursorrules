# Loop Server - Cursor Rules

## Project Overview

This is a GraphQL API server built with Go, using:

- **Framework**: gqlgen (GraphQL)
- **Database**: PostgreSQL with pgxpool
- **Authentication**: JWT (RSA256) with access/refresh tokens
- **Password Hashing**: Argon2id
- **Logging**: zerolog (structured logging)
- **Testing**: testify (require/assert)

## Project Structure

```
server/
├── graph/              # GraphQL layer
│   ├── schema.graphqls # GraphQL schema definition
│   ├── schema.resolvers.go  # Resolver implementations (generated + custom)
│   ├── helpers.go     # Helper functions (NOT generated, safe to edit)
│   ├── directives/     # @auth and @admin directives
│   └── model/         # Generated GraphQL models
├── internal/          # Internal packages (not importable outside)
│   ├── auth/          # Authentication & authorization
│   ├── config/        # Configuration management
│   ├── email/         # Email service (interface-based)
│   ├── logger/        # Logging setup
│   ├── middleware/    # HTTP middleware
│   └── validation/    # Input validation
├── migrations/        # Database migrations (numbered, up/down)
└── server.go          # Main entry point

```

## Code Generation Rules

### GraphQL Code Generation

- **NEVER** edit `graph/generated.go` or `graph/model/models_gen.go` - they are auto-generated
- **NEVER** edit `graph/schema.resolvers.go` directly - it's regenerated by gqlgen
- **ALWAYS** put custom helper functions in `graph/helpers.go` (not in resolvers file)
- After schema changes, run `make gen` to regenerate code
- Custom resolver logic goes in `schema.resolvers.go` but will be preserved by gqlgen

### Migration Files

- Use numbered migrations: `000001_name.up.sql` and `000001_name.down.sql`
- Always create both up and down migrations
- Use `make migrate-create` to create new migrations
- Test migrations with `make migrate-up` and `make migrate-down`

## Coding Standards

### Package Organization

- All internal code goes in `internal/` package (not importable outside module)
- Keep packages focused: `auth/` for auth, `email/` for email, etc.
- Use interfaces for services (e.g., `email.Service`) to allow mocking

### Naming Conventions

- **Files**: snake_case for migrations, camelCase for Go files
- **Functions**: PascalCase for exported, camelCase for private
- **Constants**: PascalCase or UPPER_CASE
- **Context keys**: Use typed `contextKey` type (see `auth/auth.go`)
- **Database types**: Prefix with `DB` (e.g., `DBUser`)

### Error Handling

- **ALWAYS** use `graphql.AddError()` for GraphQL errors with proper error codes
- Use error codes: `UNAUTHENTICATED`, `FORBIDDEN`, `INVALID_INPUT`, `ALREADY_EXISTS`, etc.
- Return errors from `internal/auth/errors.go` helpers when appropriate
- Use `auth.Unauthorized(ctx)` and `auth.Forbidden(ctx)` for auth errors
- Example:
  ```go
  graphql.AddError(ctx, &gqlerror.Error{
      Message: "User with this email already exists",
      Extensions: map[string]interface{}{
          "code": "ALREADY_EXISTS",
      },
  })
  return nil, errors.New("user already exists")
  ```

### GraphQL Resolvers

#### Resolver Pattern

- Resolvers receive `ctx context.Context` as first parameter
- Access database via `r.DB` (from Resolver struct)
- Access services via `r.EmailService` (dependency injection)
- Use `dbUserToModel()` helper from `graph/helpers.go` to convert DBUser to model.User
- Always validate input using `validation.ValidateEmail()`, `validation.ValidatePassword()`, etc.

#### Authentication & Authorization

- Use `@auth` directive for authenticated endpoints
- Use `@admin` directive for admin-only endpoints
- Get user from context: `authUser, err := auth.GetUserFromContext(ctx)`
- For admin checks, directive handles it automatically
- Never check auth manually if `@auth` directive is present

#### Input Validation

- **ALWAYS** validate email: `email = strings.ToLower(strings.TrimSpace(email))` then `validation.ValidateEmail(email)`
- **ALWAYS** validate password: `validation.ValidatePassword(password)`
- Return `INVALID_INPUT` error code for validation failures
- Use `validation.ValidateStruct()` for complex structs

### Database Patterns

#### Database Access

- Use `*pgxpool.Pool` for all database operations
- Get pool from context: `db, ok := ctx.Value(auth.DBKey).(*pgxpool.Pool)`
- Always use `context.Context` as first parameter
- Use parameterized queries: `$1, $2, $3` (never string concatenation)

#### Database Types

- Use `sql.NullString`, `sql.NullTime` for nullable fields
- Use `DBUser` struct from `internal/auth/user.go` for user data
- Always scan all columns in SELECT queries
- Handle `pgx.ErrNoRows` explicitly:
  ```go
  if errors.Is(err, pgx.ErrNoRows) {
      return nil, errors.New("user not found")
  }
  ```

#### Database Functions

- All database functions in `internal/auth/` package
- Functions should be pure (no side effects beyond DB)
- Return `*DBUser` or error
- Use transactions for multi-step operations

### Migrations

#### Migration Structure

- Always use UUID primary keys: `UUID PRIMARY KEY DEFAULT gen_random_uuid()`
- Use `TIMESTAMPTZ` for timestamps (not `TIMESTAMP`)
- Use `TEXT` for strings (not `VARCHAR`)
- Add `created_at` and `updated_at` with triggers
- Use `pgcrypto` extension for UUID generation
- Add indexes for foreign keys and frequently queried columns

#### Migration Best Practices

- Test both up and down migrations
- Use `ON DELETE CASCADE` for foreign keys when appropriate
- Add constraints (UNIQUE, CHECK) at table creation
- Use `IF NOT EXISTS` for extensions
- Example:
  ```sql
  CREATE TABLE users (
      id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
      email TEXT NOT NULL UNIQUE,
      created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
      updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
  );
  ```

### Testing

#### Test Structure

- Use `auth.SetupTestDB(t)` for database tests
- Use `auth.CleanupTestDB(t, db)` for cleanup
- Skip tests if `TEST_DATABASE_URL` not set
- Use `testing.Short()` to skip integration tests in short mode
- Use `t.Helper()` in helper functions

#### Test Patterns

- Test files: `*_test.go` in same package
- Use `testify/require` for fatal assertions
- Use `testify/assert` for non-fatal assertions
- Mock services (e.g., `email.NewMockService()`) for testing
- Test both success and error cases

#### Test Setup

- Run `make test-setup` before running tests
- Tests use separate `loop_test` database
- Database is cleared and migrated on each test run
- Set `TEST_DATABASE_URL` environment variable

### Configuration

#### Environment Variables

- Required: `PORT`, `DATABASE_URL`
- Optional: `CORS_ALLOWED_ORIGINS`, `LOG_LEVEL`, `JWT_ACCESS_EXPIRES_MINUTES`, etc.
- Load with `config.Load()` which validates required vars
- Use `os.Getenv()` for optional vars with defaults

#### JWT Keys

- Require `private.pem` and `public.pem` files in server root
- Initialize with `auth.Init()` in main
- Use RSA256 algorithm
- Access tokens: 15 minutes (configurable via env)
- Refresh tokens: stored in database

### Logging

#### Logging Patterns

- Use `logger.Log` (zerolog instance) for all logging
- Use structured logging with fields:
  ```go
  logger.Log.Info().
      Str("key", "value").
      Err(err).
      Msg("message")
  ```
- Use appropriate log levels: `Debug`, `Info`, `Warn`, `Error`, `Fatal`
- Never use `fmt.Printf` or `log.Print` - use `logger.Log`

### Middleware

#### Middleware Order

1. CORS
2. Request Logging
3. Rate Limiting
4. DB Context (adds DB to context)
5. Auth Middleware (adds user to context)

#### Creating Middleware

- Return `http.Handler` or `http.HandlerFunc`
- Use `next.ServeHTTP(w, r)` to continue chain
- Add values to context: `context.WithValue(ctx, key, value)`
- Example:
  ```go
  func MyMiddleware(next http.Handler) http.Handler {
      return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
          // Do something
          next.ServeHTTP(w, r)
      })
  }
  ```

### Security

#### Password Security

- **ALWAYS** use `auth.HashPassword()` for hashing (Argon2id)
- **ALWAYS** use `auth.VerifyPassword()` for verification
- Never store plaintext passwords
- Never log passwords

#### Authentication

- Use JWT with RSA256 (not HS256)
- Short-lived access tokens (15 minutes)
- Long-lived refresh tokens (stored in DB, revocable)
- Check token expiration in middleware
- Use `Bearer` token format in Authorization header

#### Authorization

- Use `@auth` directive for authentication
- Use `@admin` directive for admin-only access
- Check roles in database, not just JWT claims
- Use `auth.RequireAdmin(ctx, db)` for admin checks

#### Account Security

- Implement account locking after failed login attempts
- Use `failed_login_attempts` and `locked_until` fields
- Lock account after 5 failed attempts for 15 minutes
- Reset attempts on successful login

### Email Service

#### Email Patterns

- Use `email.Service` interface (allows mocking)
- Use `email.NewService(config)` - returns Resend or Mock based on API key
- Use `email.NewMockService(config)` for tests
- Always include frontend URL in email links
- Use tokens, not user IDs, in email links

### Helper Functions

#### GraphQL Helpers

- Put all helper functions in `graph/helpers.go`
- **NEVER** put helpers in `schema.resolvers.go` (will be overwritten)
- Use `dbUserToModel()` to convert `*auth.DBUser` to `*model.User`
- Keep helpers pure (no side effects)

### Common Patterns

#### Email Normalization

```go
email = strings.ToLower(strings.TrimSpace(email))
```

#### Context Usage

```go
// Get user from context
authUser, err := auth.GetUserFromContext(ctx)
if err != nil {
    return nil, auth.Unauthorized(ctx)
}

// Get DB from context
db, ok := ctx.Value(auth.DBKey).(*pgxpool.Pool)
if !ok || db == nil {
    return nil, errors.New("database not available")
}
```

#### Error Response Pattern

```go
graphql.AddError(ctx, &gqlerror.Error{
    Message: "Descriptive error message",
    Extensions: map[string]interface{}{
        "code": "ERROR_CODE",
    },
})
return nil, errors.New("error message")
```

#### Database Query Pattern

```go
var user DBUser
err := db.QueryRow(ctx, `
    SELECT id, email, ...
    FROM users
    WHERE id = $1
`, userID).Scan(
    &user.ID,
    &user.Email,
    // ... all fields
)

if err != nil {
    if errors.Is(err, pgx.ErrNoRows) {
        return nil, errors.New("user not found")
    }
    return nil, err
}
```

## What NOT to Do

### ❌ Don't:

- Edit generated files (`generated.go`, `models_gen.go`)
- Put helper functions in `schema.resolvers.go` (use `helpers.go`)
- Use string concatenation for SQL queries
- Store plaintext passwords
- Log sensitive data (passwords, tokens)
- Skip input validation
- Use `fmt.Printf` or `log.Print` (use `logger.Log`)
- Create migrations without down migrations
- Hardcode configuration values
- Return errors without GraphQL error codes
- Check auth manually when `@auth` directive exists
- Use `HS256` for JWT (use `RS256`)

### ✅ Do:

- Use `make gen` after schema changes
- Put helpers in `graph/helpers.go`
- Use parameterized queries
- Hash passwords with Argon2id
- Use structured logging
- Validate all inputs
- Create both up and down migrations
- Use environment variables for config
- Add proper error codes to GraphQL errors
- Use directives for auth/admin checks
- Use RSA256 for JWT
- Write tests for new features
- Use `dbUserToModel()` helper

## Makefile Commands

### Code Generation

- `make gen` - Regenerate GraphQL code after schema changes

### Database Migrations

- `make migrate-up` - Run all pending migrations
- `make migrate-down` - Rollback the last migration (one step)
- `make migrate-create` - Create new migration files
  - **Usage**:
    - Interactive: Run `make migrate-create` and enter name when prompted
    - Non-interactive: `echo "migration_name" | make migrate-create`
  - Creates both `.up.sql` and `.down.sql` files with sequential numbering
  - Migration name should be in snake_case (e.g., `oauth_accounts`, `file_uploads`)
  - Files are created in `migrations/` directory with format: `000XXX_name.up.sql` and `000XXX_name.down.sql`
  - The `-seq` flag ensures sequential numbering automatically

### Testing

- `make test` - Run all tests (includes test-setup automatically)
- `make test-short` - Run tests in short mode (skips integration tests)
- `make test-setup` - Setup test database (creates `loop_test` DB, clears it, runs migrations)
  - Requires `.env` file with `POSTGRES_USER`, `POSTGRES_PASSWORD`, `DB_PORT`
  - Sets `TEST_DATABASE_URL` environment variable

### Development

- `make run` - Run the server (`go run server.go`)
- `make up` - Start Docker database container
- `make down` - Stop Docker database container
- `make fresh` - Stop Docker and remove volumes (clean slate)
- `make psql` - Open PostgreSQL CLI connection
- `make port` - Show local network IP addresses

## File Organization Rules

1. **GraphQL Schema**: `graph/schema.graphqls` - Single source of truth
2. **Resolvers**: `graph/schema.resolvers.go` - Auto-generated, add custom logic
3. **Helpers**: `graph/helpers.go` - Custom helper functions (safe to edit)
4. **Directives**: `graph/directives/*.go` - Auth and admin directives
5. **Auth Logic**: `internal/auth/*.go` - All authentication/authorization
6. **Database**: Use `internal/auth/user.go` for user queries
7. **Migrations**: `migrations/000XXX_name.up.sql` and `.down.sql`
8. **Tests**: `*_test.go` files next to source files

## When Adding New Features

1. **GraphQL Schema**: Add types/mutations/queries to `schema.graphqls`
2. **Run Generation**: `make gen` to generate resolver stubs
3. **Implement Resolver**: Add logic to `schema.resolvers.go`
4. **Database**: Create migration if needed (`make migrate-create`)
5. **Tests**: Write tests in `*_test.go` file
6. **Validation**: Add validation logic if needed
7. **Error Handling**: Use proper GraphQL error codes
8. **Documentation**: Update README if needed

## Code Review Checklist

- [ ] All inputs validated
- [ ] Proper error codes in GraphQL errors
- [ ] Database queries use parameters
- [ ] Passwords hashed with Argon2id
- [ ] Tests written and passing
- [ ] Migrations have both up and down
- [ ] No sensitive data in logs
- [ ] Helpers in `helpers.go`, not resolvers file
- [ ] Using `dbUserToModel()` for user conversions
- [ ] Proper use of `@auth` and `@admin` directives
- [ ] Structured logging used
- [ ] Environment variables for configuration
