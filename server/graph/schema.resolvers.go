package graph

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.84

import (
	"context"
	"database/sql"
	"errors"
	"fmt"
	"strings"
	"time"

	"github.com/brightsidedeveloper/loop/graph/model"
	"github.com/brightsidedeveloper/loop/internal/auth"
	"github.com/brightsidedeveloper/loop/internal/validation"
	pgx "github.com/jackc/pgx/v5"
)

// Signup is the resolver for the signup field.
func (r *mutationResolver) Signup(ctx context.Context, email string, password string) (*model.Session, error) {
	email = strings.ToLower(strings.TrimSpace(email))
	if err := validation.ValidateEmail(email); err != nil {
		AddError(ctx, ErrorCodeInvalidInput, err.Error())
		return nil, err
	}

	if err := validation.ValidatePassword(password); err != nil {
		AddError(ctx, ErrorCodeInvalidInput, err.Error())
		return nil, err
	}

	existingUser, err := auth.GetUserByEmail(ctx, r.DB, email)
	if err == nil && existingUser != nil {
		AddError(ctx, ErrorCodeAlreadyExists, "User with this email already exists")
		return nil, errors.New("user already exists")
	}
	if err != nil && !errors.Is(err, auth.ErrInvalidPassword) {
		return nil, err
	}

	passwordHash, err := auth.HashPassword(password)
	if err != nil {
		return nil, err
	}

	dbUser, err := auth.CreateUser(ctx, r.DB, email, passwordHash, nil, nil)
	if err != nil {
		if strings.Contains(err.Error(), "23505") || strings.Contains(err.Error(), "unique") {
			AddError(ctx, ErrorCodeAlreadyExists, "User with this email already exists")
			return nil, errors.New("user already exists")
		}
		return nil, err
	}

	// Generate access token
	accessToken, err := auth.GenerateAccessToken(dbUser.ID)
	if err != nil {
		return nil, err
	}

	// Generate and store refresh token
	refreshToken, err := auth.CreateRefreshToken(ctx, r.DB, dbUser.ID)
	if err != nil {
		return nil, err
	}

	return &model.Session{
		AccessToken:  accessToken,
		RefreshToken: refreshToken,
	}, nil
}

// Login is the resolver for the login field.
func (r *mutationResolver) Login(ctx context.Context, email string, password string) (*model.Session, error) {
	email = strings.ToLower(strings.TrimSpace(email))

	dbUser, err := auth.GetUserByEmail(ctx, r.DB, email)
	if err != nil {
		AddError(ctx, ErrorCodeInvalidCredentials, "Invalid email or password")
		return nil, errors.New("invalid credentials")
	}

	if dbUser.IsAccountLocked() {
		AddError(ctx, ErrorCodeAccountLocked, "Account is locked due to too many failed login attempts")
		return nil, errors.New("account locked")
	}

	valid, err := auth.VerifyPassword(password, dbUser.PasswordHash)
	if err != nil {
		return nil, err
	}

	if !valid {
		_ = auth.IncrementFailedLoginAttempts(ctx, r.DB, dbUser.ID)

		if dbUser.FailedLoginAttempts >= 4 {
			lockUntil := time.Now().Add(15 * time.Minute)
			_, _ = r.DB.Exec(ctx, `
				UPDATE users
				SET locked_until = $1
				WHERE id = $2
			`, lockUntil, dbUser.ID)
		}

		AddError(ctx, ErrorCodeInvalidCredentials, "Invalid email or password")
		return nil, errors.New("invalid credentials")
	}

	if dbUser.FailedLoginAttempts > 0 {
		_ = auth.ResetFailedLoginAttempts(ctx, r.DB, dbUser.ID)
	}

	// Generate access token
	accessToken, err := auth.GenerateAccessToken(dbUser.ID)
	if err != nil {
		return nil, err
	}

	// Generate and store refresh token
	refreshToken, err := auth.CreateRefreshToken(ctx, r.DB, dbUser.ID)
	if err != nil {
		return nil, err
	}

	return &model.Session{
		AccessToken:  accessToken,
		RefreshToken: refreshToken,
	}, nil
}

// Logout is the resolver for the logout field.
func (r *mutationResolver) Logout(ctx context.Context) (bool, error) {
	// Get user from context (set by auth middleware)
	authUser, err := auth.GetUserFromContext(ctx)
	if err != nil {
		return false, auth.Unauthorized(ctx)
	}

	// Revoke all refresh tokens for this user
	err = auth.RevokeAllUserRefreshTokens(ctx, r.DB, authUser.ID)
	if err != nil {
		return false, err
	}

	return true, nil
}

// RefreshToken is the resolver for the refreshToken field.
func (r *mutationResolver) RefreshToken(ctx context.Context, refreshToken string) (*model.Session, error) {
	rt, err := auth.ValidateRefreshToken(ctx, r.DB, refreshToken)
	if err != nil {
		AddError(ctx, ErrorCodeUnauthenticated, "Invalid or expired refresh token")
		return nil, auth.ErrUnauthorized
	}

	// Revoke the old refresh token (token rotation for security)
	err = auth.RevokeRefreshToken(ctx, r.DB, refreshToken)
	if err != nil {
		return nil, err
	}

	// Generate new access token
	accessToken, err := auth.GenerateAccessToken(rt.UserID)
	if err != nil {
		return nil, err
	}

	// Generate new refresh token
	newRefreshToken, err := auth.CreateRefreshToken(ctx, r.DB, rt.UserID)
	if err != nil {
		return nil, err
	}

	return &model.Session{
		AccessToken:  accessToken,
		RefreshToken: newRefreshToken,
	}, nil
}

// UpdateUser is the resolver for the updateUser field.
func (r *mutationResolver) UpdateUser(ctx context.Context, input model.UpdateUserInput) (*model.User, error) {
	// Get user from context (set by auth middleware)
	authUser, err := auth.GetUserFromContext(ctx)
	if err != nil {
		return nil, auth.Unauthorized(ctx)
	}

	// Update user in database
	dbUser, err := auth.UpdateUser(ctx, r.DB, authUser.ID, input.FirstName, input.LastName)
	if err != nil {
		return nil, err
	}

	return dbUserToModel(dbUser), nil
}

// SendVerificationEmail is the resolver for the sendVerificationEmail field.
func (r *mutationResolver) SendVerificationEmail(ctx context.Context) (bool, error) {
	// Get user from context
	authUser, err := auth.GetUserFromContext(ctx)
	if err != nil {
		return false, auth.Unauthorized(ctx)
	}

	// Get user details
	dbUser, err := auth.GetUserByID(ctx, r.DB, authUser.ID)
	if err != nil {
		return false, err
	}

	if auth.IsEmailVerified(dbUser.EmailVerifiedAt) {
		AddError(ctx, ErrorCodeAlreadyVerified, "Email is already verified")
		return false, errors.New("email already verified")
	}

	// Create verification token
	token, err := auth.CreateEmailVerificationToken(ctx, r.DB, authUser.ID)
	if err != nil {
		return false, err
	}

	// Send verification email
	err = r.EmailService.SendVerificationEmail(dbUser.Email, token)
	if err != nil {
		return false, err
	}

	return true, nil
}

// VerifyEmail is the resolver for the verifyEmail field.
func (r *mutationResolver) VerifyEmail(ctx context.Context, token string) (bool, error) {
	et, err := auth.ValidateEmailVerificationToken(ctx, r.DB, token)
	if err != nil {
		AddError(ctx, ErrorCodeInvalidToken, err.Error())
		return false, err
	}

	// Mark token as used
	err = auth.MarkEmailVerificationTokenAsUsed(ctx, r.DB, et.ID)
	if err != nil {
		return false, err
	}

	// Verify user's email
	err = auth.VerifyUserEmail(ctx, r.DB, et.UserID)
	if err != nil {
		return false, err
	}

	return true, nil
}

// ForgotPassword is the resolver for the forgotPassword field.
func (r *mutationResolver) ForgotPassword(ctx context.Context, email string) (bool, error) {
	// Validate email format
	email = strings.ToLower(strings.TrimSpace(email))
	if err := validation.ValidateEmail(email); err != nil {
		// Return success even if invalid (security best practice)
		return true, nil
	}

	// Get user by email (don't reveal if user exists for security)
	dbUser, err := auth.GetUserByEmail(ctx, r.DB, email)
	if err != nil {
		// Return success even if user doesn't exist (security best practice)
		// This prevents email enumeration attacks
		return true, nil
	}

	// Create password reset token
	token, err := auth.CreatePasswordResetToken(ctx, r.DB, dbUser.ID)
	if err != nil {
		return false, err
	}

	// Send password reset email
	err = r.EmailService.SendPasswordResetEmail(dbUser.Email, token)
	if err != nil {
		return false, err
	}

	// Always return true (don't reveal if email exists)
	return true, nil
}

// ResetPassword is the resolver for the resetPassword field.
func (r *mutationResolver) ResetPassword(ctx context.Context, token string, newPassword string) (bool, error) {
	if err := validation.ValidatePassword(newPassword); err != nil {
		AddError(ctx, ErrorCodeInvalidInput, err.Error())
		return false, err
	}

	prt, err := auth.ValidatePasswordResetToken(ctx, r.DB, token)
	if err != nil {
		AddError(ctx, ErrorCodeInvalidToken, err.Error())
		return false, err
	}

	// Hash new password
	passwordHash, err := auth.HashPassword(newPassword)
	if err != nil {
		return false, err
	}

	// Update user password
	err = auth.UpdateUserPassword(ctx, r.DB, prt.UserID, passwordHash)
	if err != nil {
		return false, err
	}

	// Mark token as used
	err = auth.MarkPasswordResetTokenAsUsed(ctx, r.DB, prt.ID)
	if err != nil {
		return false, err
	}

	// Revoke all refresh tokens for security (force re-login)
	_ = auth.RevokeAllUserRefreshTokens(ctx, r.DB, prt.UserID)

	return true, nil
}

// ChangePassword is the resolver for the changePassword field.
func (r *mutationResolver) ChangePassword(ctx context.Context, oldPassword string, newPassword string) (bool, error) {
	// Get user from context
	authUser, err := auth.GetUserFromContext(ctx)
	if err != nil {
		return false, auth.Unauthorized(ctx)
	}

	if len(newPassword) < 8 {
		AddError(ctx, ErrorCodeInvalidInput, "Password must be at least 8 characters long")
		return false, errors.New("password too short")
	}

	dbUser, err := auth.GetUserByID(ctx, r.DB, authUser.ID)
	if err != nil {
		return false, err
	}

	valid, err := auth.VerifyPassword(oldPassword, dbUser.PasswordHash)
	if err != nil {
		return false, err
	}

	if !valid {
		AddError(ctx, ErrorCodeInvalidCredentials, "Current password is incorrect")
		return false, errors.New("invalid credentials")
	}

	// Hash new password
	passwordHash, err := auth.HashPassword(newPassword)
	if err != nil {
		return false, err
	}

	// Update password
	err = auth.UpdateUserPassword(ctx, r.DB, authUser.ID, passwordHash)
	if err != nil {
		return false, err
	}

	// Revoke all refresh tokens for security (force re-login)
	_ = auth.RevokeAllUserRefreshTokens(ctx, r.DB, authUser.ID)

	return true, nil
}

// RevokeUserTokens is the resolver for the revokeUserTokens field.
func (r *mutationResolver) RevokeUserTokens(ctx context.Context, userID string) (bool, error) {
	// Admin check is done by @admin directive
	if err := auth.RevokeAllUserRefreshTokens(ctx, r.DB, userID); err != nil {
		return false, err
	}
	return true, nil
}

// LockUser is the resolver for the lockUser field.
func (r *mutationResolver) LockUser(ctx context.Context, userID string, durationMinutes *int32) (bool, error) {
	// Admin check is done by @admin directive
	duration := 60 // default 60 minutes
	if durationMinutes != nil {
		duration = int(*durationMinutes)
	}

	if err := auth.LockUser(ctx, r.DB, userID, duration); err != nil {
		return false, err
	}
	return true, nil
}

// UnlockUser is the resolver for the unlockUser field.
func (r *mutationResolver) UnlockUser(ctx context.Context, userID string) (bool, error) {
	// Admin check is done by @admin directive
	if err := auth.UnlockUser(ctx, r.DB, userID); err != nil {
		return false, err
	}
	return true, nil
}

// DeleteUser is the resolver for the deleteUser field.
func (r *mutationResolver) DeleteUser(ctx context.Context, userID string) (bool, error) {
	// Admin check is done by @admin directive
	err := auth.DeleteUser(ctx, r.DB, userID)
	if err != nil {
		return false, err
	}

	return true, nil
}

// UpdateUserRole is the resolver for the updateUserRole field.
func (r *mutationResolver) UpdateUserRole(ctx context.Context, userID string, role model.UserRole) (*model.User, error) {
	// Admin check is done by @admin directive
	roleStr := "user"
	if role == model.UserRoleAdmin {
		roleStr = "admin"
	}

	if err := auth.UpdateUserRole(ctx, r.DB, userID, roleStr); err != nil {
		return nil, err
	}

	// Fetch updated user
	dbUser, err := auth.GetUserByID(ctx, r.DB, userID)
	if err != nil {
		return nil, err
	}

	return dbUserToModel(dbUser), nil
}

// CreateHabit is the resolver for the createHabit field.
func (r *mutationResolver) CreateHabit(ctx context.Context, input model.CreateHabitInput) (*model.Habit, error) {
	// Get user from context
	authUser, err := auth.GetUserFromContext(ctx)
	if err != nil {
		return nil, auth.Unauthorized(ctx)
	}

	// Validate input
	title := strings.TrimSpace(input.Title)
	days := make([]int32, len(input.Days))
	for i, d := range input.Days {
		days[i] = int32(d)
	}
	timeStr := strings.TrimSpace(input.Time)
	priority := int32(input.Priority)

	if err := validateHabitInput(&title, days, &timeStr, &priority); err != nil {
		AddError(ctx, ErrorCodeInvalidInput, err.Error())
		return nil, err
	}

	// Handle optional description
	var description sql.NullString
	if input.Description != nil {
		desc := strings.TrimSpace(*input.Description)
		if desc != "" {
			description = sql.NullString{String: desc, Valid: true}
		}
	}

	// Insert habit
	var habit DBHabit
	err = r.DB.QueryRow(ctx, `
		INSERT INTO habits (user_id, title, description, days, time, priority)
		VALUES ($1, $2, $3, $4, $5, $6)
		RETURNING id, user_id, title, description, created_at, updated_at,
		          days, time, priority, streak, longest_streak, last_completed_at
	`, authUser.ID, title, description, days, timeStr, priority).Scan(
		&habit.ID,
		&habit.UserID,
		&habit.Title,
		&habit.Description,
		&habit.CreatedAt,
		&habit.UpdatedAt,
		&habit.Days,
		&habit.Time,
		&habit.Priority,
		&habit.Streak,
		&habit.LongestStreak,
		&habit.LastCompletedAt,
	)
	if err != nil {
		return nil, err
	}

	return dbHabitToModel(&habit), nil
}

// UpdateHabit is the resolver for the updateHabit field.
func (r *mutationResolver) UpdateHabit(ctx context.Context, id string, input model.UpdateHabitInput) (*model.Habit, error) {
	// Get user from context
	authUser, err := auth.GetUserFromContext(ctx)
	if err != nil {
		return nil, auth.Unauthorized(ctx)
	}

	// Verify habit exists and belongs to user
	habit, err := getHabitByIDAndUser(ctx, r.DB, id, authUser.ID)
	if err != nil {
		AddError(ctx, ErrorCodeInvalidInput, "Habit not found")
		return nil, err
	}

	// Prepare update values
	var title *string
	var description sql.NullString
	var days []int32
	var timeStr *string
	var priority *int32

	if input.Title != nil {
		t := strings.TrimSpace(*input.Title)
		title = &t
	} else {
		title = &habit.Title
	}

	if input.Description != nil {
		desc := strings.TrimSpace(*input.Description)
		if desc != "" {
			description = sql.NullString{String: desc, Valid: true}
		} else {
			description = sql.NullString{Valid: false}
		}
	} else {
		description = habit.Description
	}

	if input.Days != nil {
		days = make([]int32, len(input.Days))
		for i, d := range input.Days {
			days[i] = int32(d)
		}
	} else {
		days = habit.Days
	}

	if input.Time != nil {
		t := strings.TrimSpace(*input.Time)
		timeStr = &t
	} else {
		timeStr = &habit.Time
	}

	if input.Priority != nil {
		p := int32(*input.Priority)
		priority = &p
	} else {
		priority = &habit.Priority
	}

	// Validate all values together
	if err := validateHabitInput(title, days, timeStr, priority); err != nil {
		AddError(ctx, ErrorCodeInvalidInput, err.Error())
		return nil, err
	}

	// Build dynamic UPDATE query
	updateFields := []string{}
	args := []interface{}{}
	argPos := 1

	if input.Title != nil {
		updateFields = append(updateFields, fmt.Sprintf("title = $%d", argPos))
		args = append(args, *title)
		argPos++
	}

	if input.Description != nil {
		updateFields = append(updateFields, fmt.Sprintf("description = $%d", argPos))
		args = append(args, description)
		argPos++
	}

	if input.Days != nil {
		updateFields = append(updateFields, fmt.Sprintf("days = $%d", argPos))
		args = append(args, days)
		argPos++
	}

	if input.Time != nil {
		updateFields = append(updateFields, fmt.Sprintf("time = $%d", argPos))
		args = append(args, *timeStr)
		argPos++
	}

	if input.Priority != nil {
		updateFields = append(updateFields, fmt.Sprintf("priority = $%d", argPos))
		args = append(args, *priority)
		argPos++
	}

	if len(updateFields) == 0 {
		// No fields to update, return existing habit
		return dbHabitToModel(habit), nil
	}

	// Add WHERE clause
	args = append(args, id, authUser.ID)
	whereClause := fmt.Sprintf("WHERE id = $%d AND user_id = $%d", argPos, argPos+1)

	// Execute update
	var updatedHabit DBHabit
	query := fmt.Sprintf(`
		UPDATE habits
		SET %s
		%s
		RETURNING id, user_id, title, description, created_at, updated_at,
		          days, time, priority, streak, longest_streak, last_completed_at
	`, strings.Join(updateFields, ", "), whereClause)

	err = r.DB.QueryRow(ctx, query, args...).Scan(
		&updatedHabit.ID,
		&updatedHabit.UserID,
		&updatedHabit.Title,
		&updatedHabit.Description,
		&updatedHabit.CreatedAt,
		&updatedHabit.UpdatedAt,
		&updatedHabit.Days,
		&updatedHabit.Time,
		&updatedHabit.Priority,
		&updatedHabit.Streak,
		&updatedHabit.LongestStreak,
		&updatedHabit.LastCompletedAt,
	)
	if err != nil {
		if errors.Is(err, pgx.ErrNoRows) {
			AddError(ctx, ErrorCodeInvalidInput, "Habit not found")
			return nil, errors.New("habit not found")
		}
		return nil, err
	}

	return dbHabitToModel(&updatedHabit), nil
}

// CompleteHabit is the resolver for the completeHabit field.
func (r *mutationResolver) CompleteHabit(ctx context.Context, id string, timezone string) (bool, error) {
	// Get user from context
	authUser, err := auth.GetUserFromContext(ctx)
	if err != nil {
		return false, auth.Unauthorized(ctx)
	}

	// Verify habit exists and belongs to user
	_, err = getHabitByIDAndUser(ctx, r.DB, id, authUser.ID)
	if err != nil {
		AddError(ctx, ErrorCodeInvalidInput, "Habit not found")
		return false, err
	}

	// Get timezone (required parameter)
	tz := timezone
	if tz == "" {
		tz = "UTC"
	}

	// Check if already completed today (using user's timezone)
	var existingID string
	err = r.DB.QueryRow(ctx, `
		SELECT id FROM habit_completions
		WHERE habit_id = $1 
		  AND (created_at AT TIME ZONE $2)::date = (NOW() AT TIME ZONE $2)::date
	`, id, tz).Scan(&existingID)

	if err == nil {
		// Already completed today, update to not skipped
		_, err = r.DB.Exec(ctx, `
			UPDATE habit_completions
			SET skipped = false
			WHERE id = $1
		`, existingID)
		if err != nil {
			return false, err
		}
	} else if errors.Is(err, pgx.ErrNoRows) {
		// Create new completion record
		_, err = r.DB.Exec(ctx, `
			INSERT INTO habit_completions (habit_id, skipped)
			VALUES ($1, false)
		`, id)
		if err != nil {
			return false, err
		}
	} else {
		return false, err
	}

	// Update habit: increment streak, update longest streak, update last_completed_at
	_, err = r.DB.Exec(ctx, `
		UPDATE habits
		SET streak = streak + 1,
		    longest_streak = GREATEST(longest_streak, streak + 1),
		    last_completed_at = NOW()
		WHERE id = $1
	`, id)
	if err != nil {
		return false, err
	}

	return true, nil
}

// SkipHabit is the resolver for the skipHabit field.
func (r *mutationResolver) SkipHabit(ctx context.Context, id string, timezone string) (bool, error) {
	// Get user from context
	authUser, err := auth.GetUserFromContext(ctx)
	if err != nil {
		return false, auth.Unauthorized(ctx)
	}

	// Verify habit exists and belongs to user
	_, err = getHabitByIDAndUser(ctx, r.DB, id, authUser.ID)
	if err != nil {
		AddError(ctx, ErrorCodeInvalidInput, "Habit not found")
		return false, err
	}

	// Get timezone (required parameter)
	tz := timezone
	if tz == "" {
		tz = "UTC"
	}

	// Check if already completed/skipped today (using user's timezone)
	var existingID string
	err = r.DB.QueryRow(ctx, `
		SELECT id FROM habit_completions
		WHERE habit_id = $1 
		  AND (created_at AT TIME ZONE $2)::date = (NOW() AT TIME ZONE $2)::date
	`, id, tz).Scan(&existingID)

	if err == nil {
		// Already has a record today, update to skipped
		_, err = r.DB.Exec(ctx, `
			UPDATE habit_completions
			SET skipped = true
			WHERE id = $1
		`, existingID)
		if err != nil {
			return false, err
		}
	} else if errors.Is(err, pgx.ErrNoRows) {
		// Create new skip record
		_, err = r.DB.Exec(ctx, `
			INSERT INTO habit_completions (habit_id, skipped)
			VALUES ($1, true)
		`, id)
		if err != nil {
			return false, err
		}
	} else {
		return false, err
	}

	// Update habit: reset streak to 0
	_, err = r.DB.Exec(ctx, `
		UPDATE habits
		SET streak = 0
		WHERE id = $1
	`, id)
	if err != nil {
		return false, err
	}

	return true, nil
}

// DeleteHabit is the resolver for the deleteHabit field.
func (r *mutationResolver) DeleteHabit(ctx context.Context, id string) (bool, error) {
	// Get user from context
	authUser, err := auth.GetUserFromContext(ctx)
	if err != nil {
		return false, auth.Unauthorized(ctx)
	}

	// Verify habit exists and belongs to user
	_, err = getHabitByIDAndUser(ctx, r.DB, id, authUser.ID)
	if err != nil {
		AddError(ctx, ErrorCodeInvalidInput, "Habit not found")
		return false, err
	}

	// Delete habit (CASCADE will handle habit_completions)
	result, err := r.DB.Exec(ctx, `
		DELETE FROM habits
		WHERE id = $1 AND user_id = $2
	`, id, authUser.ID)
	if err != nil {
		return false, err
	}

	if result.RowsAffected() == 0 {
		AddError(ctx, ErrorCodeInvalidInput, "Habit not found")
		return false, errors.New("habit not found")
	}

	return true, nil
}

// Me is the resolver for the me field.
func (r *queryResolver) Me(ctx context.Context) (*model.User, error) {
	// Get user from context (set by auth middleware)
	authUser, err := auth.GetUserFromContext(ctx)
	if err != nil {
		return nil, auth.Unauthorized(ctx)
	}

	// Fetch full user details from database
	dbUser, err := auth.GetUserByID(ctx, r.DB, authUser.ID)
	if err != nil {
		return nil, err
	}

	return dbUserToModel(dbUser), nil
}

// AllUsers is the resolver for the allUsers field.
func (r *queryResolver) AllUsers(ctx context.Context, limit *int32, offset *int32) (*model.UsersConnection, error) {
	// Admin check is done by @admin directive

	limitVal := 50
	if limit != nil {
		limitVal = int(*limit)
		if limitVal > 100 {
			limitVal = 100 // Max 100 per page
		}
	}

	offsetVal := 0
	if offset != nil {
		offsetVal = int(*offset)
	}

	users, err := auth.GetAllUsers(ctx, r.DB, limitVal, offsetVal)
	if err != nil {
		return nil, err
	}

	totalCount, err := auth.GetUserCount(ctx, r.DB)
	if err != nil {
		return nil, err
	}

	modelUsers := make([]*model.User, len(users))
	for i, user := range users {
		modelUsers[i] = dbUserToModel(user)
	}

	hasMore := offsetVal+limitVal < totalCount

	return &model.UsersConnection{
		Users:      modelUsers,
		TotalCount: int32(totalCount),
		HasMore:    hasMore,
	}, nil
}

// User is the resolver for the user field.
func (r *queryResolver) User(ctx context.Context, id string) (*model.User, error) {
	// Admin check is done by @admin directive

	dbUser, err := auth.GetUserByID(ctx, r.DB, id)
	if err != nil {
		return nil, err
	}

	return dbUserToModel(dbUser), nil
}

// SystemStats is the resolver for the systemStats field.
func (r *queryResolver) SystemStats(ctx context.Context) (*model.SystemStats, error) {
	// Admin check is done by @admin directive

	var stats model.SystemStats

	// Total users
	totalUsers, err := auth.GetUserCount(ctx, r.DB)
	if err != nil {
		return nil, err
	}
	stats.TotalUsers = int32(totalUsers)

	// Verified users
	err = r.DB.QueryRow(ctx, `
		SELECT COUNT(*) FROM users WHERE email_verified_at IS NOT NULL
	`).Scan(&stats.VerifiedUsers)
	if err != nil {
		return nil, err
	}

	// Locked users
	err = r.DB.QueryRow(ctx, `
		SELECT COUNT(*) FROM users WHERE locked_until > NOW()
	`).Scan(&stats.LockedUsers)
	if err != nil {
		return nil, err
	}

	// Admin users
	err = r.DB.QueryRow(ctx, `
		SELECT COUNT(*) FROM users WHERE role = 'admin'
	`).Scan(&stats.AdminUsers)
	if err != nil {
		return nil, err
	}

	return &stats, nil
}

// Habits is the resolver for the habits field.
func (r *queryResolver) Habits(ctx context.Context, timezone string) ([]*model.Habit, error) {
	// Get user from context (set by auth middleware)
	authUser, err := auth.GetUserFromContext(ctx)
	if err != nil {
		return nil, auth.Unauthorized(ctx)
	}

	// Get timezone (required parameter)
	tz := timezone
	if tz == "" {
		tz = "UTC"
	}

	// Query habits that:
	// 1. Belong to the user
	// 2. Are scheduled for today (today's day of week is in the days array) - using user's timezone
	// 3. Haven't been completed or skipped today - using user's timezone
	// 4. Ordered by time (ascending) and priority (descending)
	// Note: EXTRACT(DOW FROM date) returns 0=Sunday, 1=Monday, ..., 6=Saturday
	// We use AT TIME ZONE to convert timestamps to the user's timezone before extracting the date
	rows, err := r.DB.Query(ctx, `
		SELECT h.id, h.user_id, h.title, h.description, h.created_at, h.updated_at,
		       h.days, h.time, h.priority, h.streak, h.longest_streak, h.last_completed_at,
		       false as skipped,
		       false as completed
		FROM habits h
		WHERE h.user_id = $1
		  AND (EXTRACT(DOW FROM (NOW() AT TIME ZONE $2)::date)::int) = ANY(h.days)
		  AND NOT EXISTS (
		    SELECT 1
		    FROM habit_completions hc
		    WHERE hc.habit_id = h.id
		      AND DATE(hc.created_at AT TIME ZONE $2) = DATE(NOW() AT TIME ZONE $2)
		  )
		ORDER BY h.time ASC, h.priority DESC
	`, authUser.ID, tz)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var habits []*model.Habit
	for rows.Next() {
		var habit DBHabit
		err := rows.Scan(
			&habit.ID,
			&habit.UserID,
			&habit.Title,
			&habit.Description,
			&habit.CreatedAt,
			&habit.UpdatedAt,
			&habit.Days,
			&habit.Time,
			&habit.Priority,
			&habit.Streak,
			&habit.LongestStreak,
			&habit.LastCompletedAt,
			&habit.Skipped,
			&habit.Completed,
		)
		if err != nil {
			return nil, err
		}
		habits = append(habits, dbHabitToModel(&habit))
	}

	if err := rows.Err(); err != nil {
		return nil, err
	}

	return habits, nil
}

// AllHabits is the resolver for the allHabits field.
func (r *queryResolver) AllHabits(ctx context.Context, timezone string) ([]*model.Habit, error) {
	// Get user from context (set by auth middleware)
	authUser, err := auth.GetUserFromContext(ctx)
	if err != nil {
		return nil, auth.Unauthorized(ctx)
	}

	// Get timezone (required parameter)
	tz := timezone
	if tz == "" {
		tz = "UTC"
	}

	// Query all habits for the user with completion status for today
	rows, err := r.DB.Query(ctx, `
		SELECT h.id, h.user_id, h.title, h.description, h.created_at, h.updated_at,
		       h.days, h.time, h.priority, h.streak, h.longest_streak, h.last_completed_at,
		       COALESCE(hc_today.skipped, false) as skipped,
		       COALESCE(hc_today.skipped = false AND hc_today.id IS NOT NULL, false) as completed
		FROM habits h
		LEFT JOIN LATERAL (
		  SELECT hc.id, hc.skipped
		  FROM habit_completions hc
		  WHERE hc.habit_id = h.id
		    AND DATE(hc.created_at AT TIME ZONE $2) = DATE(NOW() AT TIME ZONE $2)
		  LIMIT 1
		) hc_today ON true
		WHERE h.user_id = $1
		ORDER BY h.time ASC, h.priority DESC
	`, authUser.ID, tz)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var habits []*model.Habit
	for rows.Next() {
		var habit DBHabit
		err := rows.Scan(
			&habit.ID,
			&habit.UserID,
			&habit.Title,
			&habit.Description,
			&habit.CreatedAt,
			&habit.UpdatedAt,
			&habit.Days,
			&habit.Time,
			&habit.Priority,
			&habit.Streak,
			&habit.LongestStreak,
			&habit.LastCompletedAt,
			&habit.Skipped,
			&habit.Completed,
		)
		if err != nil {
			return nil, err
		}
		habits = append(habits, dbHabitToModel(&habit))
	}

	if err := rows.Err(); err != nil {
		return nil, err
	}

	return habits, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
