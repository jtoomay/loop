package graph

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.84

import (
	"context"
	"errors"
	"strings"
	"time"

	"github.com/99designs/gqlgen/graphql"
	"github.com/brightsidedeveloper/loop/graph/model"
	"github.com/brightsidedeveloper/loop/internal/auth"
	"github.com/brightsidedeveloper/loop/internal/validation"
	"github.com/vektah/gqlparser/v2/gqlerror"
)

// Signup is the resolver for the signup field.
func (r *mutationResolver) Signup(ctx context.Context, email string, password string) (*model.Session, error) {
	// Validate email format
	email = strings.ToLower(strings.TrimSpace(email))
	if err := validation.ValidateEmail(email); err != nil {
		graphql.AddError(ctx, &gqlerror.Error{
			Message: err.Error(),
			Extensions: map[string]interface{}{
				"code": "INVALID_INPUT",
			},
		})
		return nil, err
	}

	// Validate password
	if err := validation.ValidatePassword(password); err != nil {
		graphql.AddError(ctx, &gqlerror.Error{
			Message: err.Error(),
			Extensions: map[string]interface{}{
				"code": "INVALID_INPUT",
			},
		})
		return nil, err
	}

	// Check if user already exists
	existingUser, err := auth.GetUserByEmail(ctx, r.DB, email)
	if err == nil && existingUser != nil {
		graphql.AddError(ctx, &gqlerror.Error{
			Message: "User with this email already exists",
			Extensions: map[string]interface{}{
				"code": "ALREADY_EXISTS",
			},
		})
		return nil, errors.New("user already exists")
	}
	if err != nil && !errors.Is(err, auth.ErrInvalidPassword) {
		return nil, err
	}

	// Hash password
	passwordHash, err := auth.HashPassword(password)
	if err != nil {
		return nil, err
	}

	// Create user (firstName and lastName will be set via updateUser mutation)
	dbUser, err := auth.CreateUser(ctx, r.DB, email, passwordHash, nil, nil)
	if err != nil {
		// Check for unique constraint violation (PostgreSQL error code 23505)
		if strings.Contains(err.Error(), "23505") || strings.Contains(err.Error(), "unique") {
			graphql.AddError(ctx, &gqlerror.Error{
				Message: "User with this email already exists",
				Extensions: map[string]interface{}{
					"code": "ALREADY_EXISTS",
				},
			})
			return nil, errors.New("user already exists")
		}
		return nil, err
	}

	// Generate access token
	accessToken, err := auth.GenerateAccessToken(dbUser.ID)
	if err != nil {
		return nil, err
	}

	// Generate and store refresh token
	refreshToken, err := auth.CreateRefreshToken(ctx, r.DB, dbUser.ID)
	if err != nil {
		return nil, err
	}

	return &model.Session{
		AccessToken:  accessToken,
		RefreshToken: refreshToken,
	}, nil
}

// Login is the resolver for the login field.
func (r *mutationResolver) Login(ctx context.Context, email string, password string) (*model.Session, error) {
	email = strings.ToLower(strings.TrimSpace(email))

	// Get user from database
	dbUser, err := auth.GetUserByEmail(ctx, r.DB, email)
	if err != nil {
		// Don't reveal if user exists - use same error for both cases
		graphql.AddError(ctx, &gqlerror.Error{
			Message: "Invalid email or password",
			Extensions: map[string]interface{}{
				"code": "UNAUTHENTICATED",
			},
		})
		return nil, auth.ErrUnauthorized
	}

	// Check if account is locked
	if dbUser.IsAccountLocked() {
		graphql.AddError(ctx, &gqlerror.Error{
			Message: "Account is locked due to too many failed login attempts",
			Extensions: map[string]interface{}{
				"code": "ACCOUNT_LOCKED",
			},
		})
		return nil, errors.New("account locked")
	}

	// Verify password
	valid, err := auth.VerifyPassword(password, dbUser.PasswordHash)
	if err != nil {
		return nil, err
	}

	if !valid {
		// Increment failed login attempts
		_ = auth.IncrementFailedLoginAttempts(ctx, r.DB, dbUser.ID)

		// Lock account after 5 failed attempts (for 15 minutes)
		if dbUser.FailedLoginAttempts >= 4 { // 0-indexed, so 4 means 5th attempt
			lockUntil := time.Now().Add(15 * time.Minute)
			_, _ = r.DB.Exec(ctx, `
				UPDATE users
				SET locked_until = $1
				WHERE id = $2
			`, lockUntil, dbUser.ID)
		}

		graphql.AddError(ctx, &gqlerror.Error{
			Message: "Invalid email or password",
			Extensions: map[string]interface{}{
				"code": "UNAUTHENTICATED",
			},
		})
		return nil, auth.ErrUnauthorized
	}

	// Reset failed login attempts on successful login
	if dbUser.FailedLoginAttempts > 0 {
		_ = auth.ResetFailedLoginAttempts(ctx, r.DB, dbUser.ID)
	}

	// Generate access token
	accessToken, err := auth.GenerateAccessToken(dbUser.ID)
	if err != nil {
		return nil, err
	}

	// Generate and store refresh token
	refreshToken, err := auth.CreateRefreshToken(ctx, r.DB, dbUser.ID)
	if err != nil {
		return nil, err
	}

	return &model.Session{
		AccessToken:  accessToken,
		RefreshToken: refreshToken,
	}, nil
}

// Logout is the resolver for the logout field.
func (r *mutationResolver) Logout(ctx context.Context) (bool, error) {
	// Get user from context (set by auth middleware)
	authUser, err := auth.GetUserFromContext(ctx)
	if err != nil {
		return false, auth.Unauthorized(ctx)
	}

	// Revoke all refresh tokens for this user
	err = auth.RevokeAllUserRefreshTokens(ctx, r.DB, authUser.ID)
	if err != nil {
		return false, err
	}

	return true, nil
}

// RefreshToken is the resolver for the refreshToken field.
func (r *mutationResolver) RefreshToken(ctx context.Context, refreshToken string) (*model.Session, error) {
	// Validate the refresh token
	rt, err := auth.ValidateRefreshToken(ctx, r.DB, refreshToken)
	if err != nil {
		graphql.AddError(ctx, &gqlerror.Error{
			Message: "Invalid or expired refresh token",
			Extensions: map[string]interface{}{
				"code": "UNAUTHENTICATED",
			},
		})
		return nil, auth.ErrUnauthorized
	}

	// Revoke the old refresh token (token rotation for security)
	err = auth.RevokeRefreshToken(ctx, r.DB, refreshToken)
	if err != nil {
		return nil, err
	}

	// Generate new access token
	accessToken, err := auth.GenerateAccessToken(rt.UserID)
	if err != nil {
		return nil, err
	}

	// Generate new refresh token
	newRefreshToken, err := auth.CreateRefreshToken(ctx, r.DB, rt.UserID)
	if err != nil {
		return nil, err
	}

	return &model.Session{
		AccessToken:  accessToken,
		RefreshToken: newRefreshToken,
	}, nil
}

// UpdateUser is the resolver for the updateUser field.
func (r *mutationResolver) UpdateUser(ctx context.Context, input model.UpdateUserInput) (*model.User, error) {
	// Get user from context (set by auth middleware)
	authUser, err := auth.GetUserFromContext(ctx)
	if err != nil {
		return nil, auth.Unauthorized(ctx)
	}

	// Update user in database
	dbUser, err := auth.UpdateUser(ctx, r.DB, authUser.ID, input.FirstName, input.LastName)
	if err != nil {
		return nil, err
	}

	return dbUserToModel(dbUser), nil
}

// SendVerificationEmail is the resolver for the sendVerificationEmail field.
func (r *mutationResolver) SendVerificationEmail(ctx context.Context) (bool, error) {
	// Get user from context
	authUser, err := auth.GetUserFromContext(ctx)
	if err != nil {
		return false, auth.Unauthorized(ctx)
	}

	// Get user details
	dbUser, err := auth.GetUserByID(ctx, r.DB, authUser.ID)
	if err != nil {
		return false, err
	}

	// Check if already verified
	if auth.IsEmailVerified(dbUser.EmailVerifiedAt) {
		graphql.AddError(ctx, &gqlerror.Error{
			Message: "Email is already verified",
			Extensions: map[string]interface{}{
				"code": "ALREADY_VERIFIED",
			},
		})
		return false, errors.New("email already verified")
	}

	// Create verification token
	token, err := auth.CreateEmailVerificationToken(ctx, r.DB, authUser.ID)
	if err != nil {
		return false, err
	}

	// Send verification email
	err = r.EmailService.SendVerificationEmail(dbUser.Email, token)
	if err != nil {
		return false, err
	}

	return true, nil
}

// VerifyEmail is the resolver for the verifyEmail field.
func (r *mutationResolver) VerifyEmail(ctx context.Context, token string) (bool, error) {
	// Validate token
	et, err := auth.ValidateEmailVerificationToken(ctx, r.DB, token)
	if err != nil {
		graphql.AddError(ctx, &gqlerror.Error{
			Message: err.Error(),
			Extensions: map[string]interface{}{
				"code": "INVALID_TOKEN",
			},
		})
		return false, err
	}

	// Mark token as used
	err = auth.MarkEmailVerificationTokenAsUsed(ctx, r.DB, et.ID)
	if err != nil {
		return false, err
	}

	// Verify user's email
	err = auth.VerifyUserEmail(ctx, r.DB, et.UserID)
	if err != nil {
		return false, err
	}

	return true, nil
}

// ForgotPassword is the resolver for the forgotPassword field.
func (r *mutationResolver) ForgotPassword(ctx context.Context, email string) (bool, error) {
	// Validate email format
	email = strings.ToLower(strings.TrimSpace(email))
	if err := validation.ValidateEmail(email); err != nil {
		// Return success even if invalid (security best practice)
		return true, nil
	}

	// Get user by email (don't reveal if user exists for security)
	dbUser, err := auth.GetUserByEmail(ctx, r.DB, email)
	if err != nil {
		// Return success even if user doesn't exist (security best practice)
		// This prevents email enumeration attacks
		return true, nil
	}

	// Create password reset token
	token, err := auth.CreatePasswordResetToken(ctx, r.DB, dbUser.ID)
	if err != nil {
		return false, err
	}

	// Send password reset email
	err = r.EmailService.SendPasswordResetEmail(dbUser.Email, token)
	if err != nil {
		return false, err
	}

	// Always return true (don't reveal if email exists)
	return true, nil
}

// ResetPassword is the resolver for the resetPassword field.
func (r *mutationResolver) ResetPassword(ctx context.Context, token string, newPassword string) (bool, error) {
	// Validate password
	if err := validation.ValidatePassword(newPassword); err != nil {
		graphql.AddError(ctx, &gqlerror.Error{
			Message: err.Error(),
			Extensions: map[string]interface{}{
				"code": "INVALID_INPUT",
			},
		})
		return false, err
	}

	// Validate token
	prt, err := auth.ValidatePasswordResetToken(ctx, r.DB, token)
	if err != nil {
		graphql.AddError(ctx, &gqlerror.Error{
			Message: err.Error(),
			Extensions: map[string]interface{}{
				"code": "INVALID_TOKEN",
			},
		})
		return false, err
	}

	// Hash new password
	passwordHash, err := auth.HashPassword(newPassword)
	if err != nil {
		return false, err
	}

	// Update user password
	err = auth.UpdateUserPassword(ctx, r.DB, prt.UserID, passwordHash)
	if err != nil {
		return false, err
	}

	// Mark token as used
	err = auth.MarkPasswordResetTokenAsUsed(ctx, r.DB, prt.ID)
	if err != nil {
		return false, err
	}

	// Revoke all refresh tokens for security (force re-login)
	_ = auth.RevokeAllUserRefreshTokens(ctx, r.DB, prt.UserID)

	return true, nil
}

// ChangePassword is the resolver for the changePassword field.
func (r *mutationResolver) ChangePassword(ctx context.Context, oldPassword string, newPassword string) (bool, error) {
	// Get user from context
	authUser, err := auth.GetUserFromContext(ctx)
	if err != nil {
		return false, auth.Unauthorized(ctx)
	}

	// Validate new password length
	if len(newPassword) < 8 {
		graphql.AddError(ctx, &gqlerror.Error{
			Message: "Password must be at least 8 characters long",
			Extensions: map[string]interface{}{
				"code": "INVALID_INPUT",
			},
		})
		return false, errors.New("password too short")
	}

	// Get user from database
	dbUser, err := auth.GetUserByID(ctx, r.DB, authUser.ID)
	if err != nil {
		return false, err
	}

	// Verify old password
	valid, err := auth.VerifyPassword(oldPassword, dbUser.PasswordHash)
	if err != nil {
		return false, err
	}

	if !valid {
		graphql.AddError(ctx, &gqlerror.Error{
			Message: "Current password is incorrect",
			Extensions: map[string]interface{}{
				"code": "UNAUTHENTICATED",
			},
		})
		return false, auth.ErrUnauthorized
	}

	// Hash new password
	passwordHash, err := auth.HashPassword(newPassword)
	if err != nil {
		return false, err
	}

	// Update password
	err = auth.UpdateUserPassword(ctx, r.DB, authUser.ID, passwordHash)
	if err != nil {
		return false, err
	}

	// Revoke all refresh tokens for security (force re-login)
	_ = auth.RevokeAllUserRefreshTokens(ctx, r.DB, authUser.ID)

	return true, nil
}

// RevokeUserTokens is the resolver for the revokeUserTokens field.
func (r *mutationResolver) RevokeUserTokens(ctx context.Context, userID string) (bool, error) {
	// Admin check is done by @admin directive
	if err := auth.RevokeAllUserRefreshTokens(ctx, r.DB, userID); err != nil {
		return false, err
	}
	return true, nil
}

// LockUser is the resolver for the lockUser field.
func (r *mutationResolver) LockUser(ctx context.Context, userID string, durationMinutes *int32) (bool, error) {
	// Admin check is done by @admin directive
	duration := 60 // default 60 minutes
	if durationMinutes != nil {
		duration = int(*durationMinutes)
	}

	if err := auth.LockUser(ctx, r.DB, userID, duration); err != nil {
		return false, err
	}
	return true, nil
}

// UnlockUser is the resolver for the unlockUser field.
func (r *mutationResolver) UnlockUser(ctx context.Context, userID string) (bool, error) {
	// Admin check is done by @admin directive
	if err := auth.UnlockUser(ctx, r.DB, userID); err != nil {
		return false, err
	}
	return true, nil
}

// DeleteUser is the resolver for the deleteUser field.
func (r *mutationResolver) DeleteUser(ctx context.Context, userID string) (bool, error) {
	// Admin check is done by @admin directive
	err := auth.DeleteUser(ctx, r.DB, userID)
	if err != nil {
		return false, err
	}

	return true, nil
}

// UpdateUserRole is the resolver for the updateUserRole field.
func (r *mutationResolver) UpdateUserRole(ctx context.Context, userID string, role model.UserRole) (*model.User, error) {
	// Admin check is done by @admin directive
	roleStr := "user"
	if role == model.UserRoleAdmin {
		roleStr = "admin"
	}

	if err := auth.UpdateUserRole(ctx, r.DB, userID, roleStr); err != nil {
		return nil, err
	}

	// Fetch updated user
	dbUser, err := auth.GetUserByID(ctx, r.DB, userID)
	if err != nil {
		return nil, err
	}

	return dbUserToModel(dbUser), nil
}

// SessionCheck is the resolver for the sessionCheck field.
func (r *queryResolver) SessionCheck(ctx context.Context) (bool, error) {
	return auth.IsAuthenticated(ctx), nil
}

// Me is the resolver for the me field.
func (r *queryResolver) Me(ctx context.Context) (*model.User, error) {
	// Get user from context (set by auth middleware)
	authUser, err := auth.GetUserFromContext(ctx)
	if err != nil {
		return nil, auth.Unauthorized(ctx)
	}

	// Fetch full user details from database
	dbUser, err := auth.GetUserByID(ctx, r.DB, authUser.ID)
	if err != nil {
		return nil, err
	}

	return dbUserToModel(dbUser), nil
}

// AllUsers is the resolver for the allUsers field.
func (r *queryResolver) AllUsers(ctx context.Context, limit *int32, offset *int32) (*model.UsersConnection, error) {
	// Admin check is done by @admin directive

	limitVal := 50
	if limit != nil {
		limitVal = int(*limit)
		if limitVal > 100 {
			limitVal = 100 // Max 100 per page
		}
	}

	offsetVal := 0
	if offset != nil {
		offsetVal = int(*offset)
	}

	users, err := auth.GetAllUsers(ctx, r.DB, limitVal, offsetVal)
	if err != nil {
		return nil, err
	}

	totalCount, err := auth.GetUserCount(ctx, r.DB)
	if err != nil {
		return nil, err
	}

	modelUsers := make([]*model.User, len(users))
	for i, user := range users {
		modelUsers[i] = dbUserToModel(user)
	}

	hasMore := offsetVal+limitVal < totalCount

	return &model.UsersConnection{
		Users:      modelUsers,
		TotalCount: int32(totalCount),
		HasMore:    hasMore,
	}, nil
}

// User is the resolver for the user field.
func (r *queryResolver) User(ctx context.Context, id string) (*model.User, error) {
	// Admin check is done by @admin directive

	dbUser, err := auth.GetUserByID(ctx, r.DB, id)
	if err != nil {
		return nil, err
	}

	return dbUserToModel(dbUser), nil
}

// SystemStats is the resolver for the systemStats field.
func (r *queryResolver) SystemStats(ctx context.Context) (*model.SystemStats, error) {
	// Admin check is done by @admin directive

	var stats model.SystemStats

	// Total users
	totalUsers, err := auth.GetUserCount(ctx, r.DB)
	if err != nil {
		return nil, err
	}
	stats.TotalUsers = int32(totalUsers)

	// Verified users
	err = r.DB.QueryRow(ctx, `
		SELECT COUNT(*) FROM users WHERE email_verified_at IS NOT NULL
	`).Scan(&stats.VerifiedUsers)
	if err != nil {
		return nil, err
	}

	// Locked users
	err = r.DB.QueryRow(ctx, `
		SELECT COUNT(*) FROM users WHERE locked_until > NOW()
	`).Scan(&stats.LockedUsers)
	if err != nil {
		return nil, err
	}

	// Admin users
	err = r.DB.QueryRow(ctx, `
		SELECT COUNT(*) FROM users WHERE role = 'admin'
	`).Scan(&stats.AdminUsers)
	if err != nil {
		return nil, err
	}

	return &stats, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
