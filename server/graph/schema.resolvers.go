package graph

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.84

import (
	"context"
	"errors"
	"strings"
	"time"

	"github.com/99designs/gqlgen/graphql"
	"github.com/brightsidedeveloper/loop/graph/model"
	"github.com/brightsidedeveloper/loop/internal/auth"
	"github.com/brightsidedeveloper/loop/internal/validation"
	"github.com/vektah/gqlparser/v2/gqlerror"
)

// Signup is the resolver for the signup field.
func (r *mutationResolver) Signup(ctx context.Context, email string, password string) (*model.Session, error) {
	// Validate email format
	email = strings.ToLower(strings.TrimSpace(email))
	if err := validation.ValidateEmail(email); err != nil {
		graphql.AddError(ctx, &gqlerror.Error{
			Message: err.Error(),
			Extensions: map[string]interface{}{
				"code": "INVALID_INPUT",
			},
		})
		return nil, err
	}

	// Validate password
	if err := validation.ValidatePassword(password); err != nil {
		graphql.AddError(ctx, &gqlerror.Error{
			Message: err.Error(),
			Extensions: map[string]interface{}{
				"code": "INVALID_INPUT",
			},
		})
		return nil, err
	}

	// Check if user already exists
	existingUser, err := auth.GetUserByEmail(ctx, r.DB, email)
	if err == nil && existingUser != nil {
		graphql.AddError(ctx, &gqlerror.Error{
			Message: "User with this email already exists",
			Extensions: map[string]interface{}{
				"code": "ALREADY_EXISTS",
			},
		})
		return nil, errors.New("user already exists")
	}
	if err != nil && !errors.Is(err, auth.ErrInvalidPassword) {
		return nil, err
	}

	// Hash password
	passwordHash, err := auth.HashPassword(password)
	if err != nil {
		return nil, err
	}

	// Create user (firstName and lastName will be set via updateUser mutation)
	dbUser, err := auth.CreateUser(ctx, r.DB, email, passwordHash, nil, nil)
	if err != nil {
		// Check for unique constraint violation (PostgreSQL error code 23505)
		if strings.Contains(err.Error(), "23505") || strings.Contains(err.Error(), "unique") {
			graphql.AddError(ctx, &gqlerror.Error{
				Message: "User with this email already exists",
				Extensions: map[string]interface{}{
					"code": "ALREADY_EXISTS",
				},
			})
			return nil, errors.New("user already exists")
		}
		return nil, err
	}

	// Generate access token
	accessToken, err := auth.GenerateAccessToken(dbUser.ID)
	if err != nil {
		return nil, err
	}

	// Generate and store refresh token
	refreshToken, err := auth.CreateRefreshToken(ctx, r.DB, dbUser.ID)
	if err != nil {
		return nil, err
	}

	return &model.Session{
		AccessToken:  accessToken,
		RefreshToken: refreshToken,
	}, nil
}

// Login is the resolver for the login field.
func (r *mutationResolver) Login(ctx context.Context, email string, password string) (*model.Session, error) {
	email = strings.ToLower(strings.TrimSpace(email))

	// Get user from database
	dbUser, err := auth.GetUserByEmail(ctx, r.DB, email)
	if err != nil {
		// Don't reveal if user exists - use same error for both cases
		graphql.AddError(ctx, &gqlerror.Error{
			Message: "Invalid email or password",
			Extensions: map[string]interface{}{
				"code": "UNAUTHENTICATED",
			},
		})
		return nil, auth.ErrUnauthorized
	}

	// Check if account is locked
	if dbUser.IsAccountLocked() {
		graphql.AddError(ctx, &gqlerror.Error{
			Message: "Account is locked due to too many failed login attempts",
			Extensions: map[string]interface{}{
				"code": "ACCOUNT_LOCKED",
			},
		})
		return nil, errors.New("account locked")
	}

	// Verify password
	valid, err := auth.VerifyPassword(password, dbUser.PasswordHash)
	if err != nil {
		return nil, err
	}

	if !valid {
		// Increment failed login attempts
		_ = auth.IncrementFailedLoginAttempts(ctx, r.DB, dbUser.ID)

		// Lock account after 5 failed attempts (for 15 minutes)
		if dbUser.FailedLoginAttempts >= 4 { // 0-indexed, so 4 means 5th attempt
			lockUntil := time.Now().Add(15 * time.Minute)
			_, _ = r.DB.Exec(ctx, `
				UPDATE users
				SET locked_until = $1
				WHERE id = $2
			`, lockUntil, dbUser.ID)
		}

		graphql.AddError(ctx, &gqlerror.Error{
			Message: "Invalid email or password",
			Extensions: map[string]interface{}{
				"code": "UNAUTHENTICATED",
			},
		})
		return nil, auth.ErrUnauthorized
	}

	// Reset failed login attempts on successful login
	if dbUser.FailedLoginAttempts > 0 {
		_ = auth.ResetFailedLoginAttempts(ctx, r.DB, dbUser.ID)
	}

	// Generate access token
	accessToken, err := auth.GenerateAccessToken(dbUser.ID)
	if err != nil {
		return nil, err
	}

	// Generate and store refresh token
	refreshToken, err := auth.CreateRefreshToken(ctx, r.DB, dbUser.ID)
	if err != nil {
		return nil, err
	}

	return &model.Session{
		AccessToken:  accessToken,
		RefreshToken: refreshToken,
	}, nil
}

// Logout is the resolver for the logout field.
func (r *mutationResolver) Logout(ctx context.Context) (bool, error) {
	// Get user from context (set by auth middleware)
	authUser, err := auth.GetUserFromContext(ctx)
	if err != nil {
		return false, auth.Unauthorized(ctx)
	}

	// Revoke all refresh tokens for this user
	err = auth.RevokeAllUserRefreshTokens(ctx, r.DB, authUser.ID)
	if err != nil {
		return false, err
	}

	return true, nil
}

// RefreshToken is the resolver for the refreshToken field.
func (r *mutationResolver) RefreshToken(ctx context.Context, refreshToken string) (*model.Session, error) {
	// Validate the refresh token
	rt, err := auth.ValidateRefreshToken(ctx, r.DB, refreshToken)
	if err != nil {
		graphql.AddError(ctx, &gqlerror.Error{
			Message: "Invalid or expired refresh token",
			Extensions: map[string]interface{}{
				"code": "UNAUTHENTICATED",
			},
		})
		return nil, auth.ErrUnauthorized
	}

	// Revoke the old refresh token (token rotation for security)
	err = auth.RevokeRefreshToken(ctx, r.DB, refreshToken)
	if err != nil {
		return nil, err
	}

	// Generate new access token
	accessToken, err := auth.GenerateAccessToken(rt.UserID)
	if err != nil {
		return nil, err
	}

	// Generate new refresh token
	newRefreshToken, err := auth.CreateRefreshToken(ctx, r.DB, rt.UserID)
	if err != nil {
		return nil, err
	}

	return &model.Session{
		AccessToken:  accessToken,
		RefreshToken: newRefreshToken,
	}, nil
}

// UpdateUser is the resolver for the updateUser field.
func (r *mutationResolver) UpdateUser(ctx context.Context, input model.UpdateUserInput) (*model.User, error) {
	// Get user from context (set by auth middleware)
	authUser, err := auth.GetUserFromContext(ctx)
	if err != nil {
		return nil, auth.Unauthorized(ctx)
	}

	// Update user in database
	dbUser, err := auth.UpdateUser(ctx, r.DB, authUser.ID, input.FirstName, input.LastName)
	if err != nil {
		return nil, err
	}

	// Extract firstName and lastName from database
	var firstNamePtr, lastNamePtr *string
	if dbUser.FirstName.Valid {
		firstNamePtr = &dbUser.FirstName.String
	}
	if dbUser.LastName.Valid {
		lastNamePtr = &dbUser.LastName.String
	}

	return &model.User{
		ID:            dbUser.ID,
		Email:         dbUser.Email,
		EmailVerified: auth.IsEmailVerified(dbUser.EmailVerifiedAt),
		FirstName:     firstNamePtr,
		LastName:      lastNamePtr,
	}, nil
}

// SendVerificationEmail is the resolver for the sendVerificationEmail field.
func (r *mutationResolver) SendVerificationEmail(ctx context.Context) (bool, error) {
	// Get user from context
	authUser, err := auth.GetUserFromContext(ctx)
	if err != nil {
		return false, auth.Unauthorized(ctx)
	}

	// Get user details
	dbUser, err := auth.GetUserByID(ctx, r.DB, authUser.ID)
	if err != nil {
		return false, err
	}

	// Check if already verified
	if auth.IsEmailVerified(dbUser.EmailVerifiedAt) {
		graphql.AddError(ctx, &gqlerror.Error{
			Message: "Email is already verified",
			Extensions: map[string]interface{}{
				"code": "ALREADY_VERIFIED",
			},
		})
		return false, errors.New("email already verified")
	}

	// Create verification token
	token, err := auth.CreateEmailVerificationToken(ctx, r.DB, authUser.ID)
	if err != nil {
		return false, err
	}

	// Send verification email
	err = r.EmailService.SendVerificationEmail(dbUser.Email, token)
	if err != nil {
		return false, err
	}

	return true, nil
}

// VerifyEmail is the resolver for the verifyEmail field.
func (r *mutationResolver) VerifyEmail(ctx context.Context, token string) (bool, error) {
	// Validate token
	et, err := auth.ValidateEmailVerificationToken(ctx, r.DB, token)
	if err != nil {
		graphql.AddError(ctx, &gqlerror.Error{
			Message: err.Error(),
			Extensions: map[string]interface{}{
				"code": "INVALID_TOKEN",
			},
		})
		return false, err
	}

	// Mark token as used
	err = auth.MarkEmailVerificationTokenAsUsed(ctx, r.DB, et.ID)
	if err != nil {
		return false, err
	}

	// Verify user's email
	err = auth.VerifyUserEmail(ctx, r.DB, et.UserID)
	if err != nil {
		return false, err
	}

	return true, nil
}

// ForgotPassword is the resolver for the forgotPassword field.
func (r *mutationResolver) ForgotPassword(ctx context.Context, email string) (bool, error) {
	// Validate email format
	email = strings.ToLower(strings.TrimSpace(email))
	if err := validation.ValidateEmail(email); err != nil {
		// Return success even if invalid (security best practice)
		return true, nil
	}

	// Get user by email (don't reveal if user exists for security)
	dbUser, err := auth.GetUserByEmail(ctx, r.DB, email)
	if err != nil {
		// Return success even if user doesn't exist (security best practice)
		// This prevents email enumeration attacks
		return true, nil
	}

	// Create password reset token
	token, err := auth.CreatePasswordResetToken(ctx, r.DB, dbUser.ID)
	if err != nil {
		return false, err
	}

	// Send password reset email
	err = r.EmailService.SendPasswordResetEmail(dbUser.Email, token)
	if err != nil {
		return false, err
	}

	// Always return true (don't reveal if email exists)
	return true, nil
}

// ResetPassword is the resolver for the resetPassword field.
func (r *mutationResolver) ResetPassword(ctx context.Context, token string, newPassword string) (bool, error) {
	// Validate password
	if err := validation.ValidatePassword(newPassword); err != nil {
		graphql.AddError(ctx, &gqlerror.Error{
			Message: err.Error(),
			Extensions: map[string]interface{}{
				"code": "INVALID_INPUT",
			},
		})
		return false, err
	}

	// Validate token
	prt, err := auth.ValidatePasswordResetToken(ctx, r.DB, token)
	if err != nil {
		graphql.AddError(ctx, &gqlerror.Error{
			Message: err.Error(),
			Extensions: map[string]interface{}{
				"code": "INVALID_TOKEN",
			},
		})
		return false, err
	}

	// Hash new password
	passwordHash, err := auth.HashPassword(newPassword)
	if err != nil {
		return false, err
	}

	// Update user password
	err = auth.UpdateUserPassword(ctx, r.DB, prt.UserID, passwordHash)
	if err != nil {
		return false, err
	}

	// Mark token as used
	err = auth.MarkPasswordResetTokenAsUsed(ctx, r.DB, prt.ID)
	if err != nil {
		return false, err
	}

	// Revoke all refresh tokens for security (force re-login)
	_ = auth.RevokeAllUserRefreshTokens(ctx, r.DB, prt.UserID)

	return true, nil
}

// ChangePassword is the resolver for the changePassword field.
func (r *mutationResolver) ChangePassword(ctx context.Context, oldPassword string, newPassword string) (bool, error) {
	// Get user from context
	authUser, err := auth.GetUserFromContext(ctx)
	if err != nil {
		return false, auth.Unauthorized(ctx)
	}

	// Validate new password length
	if len(newPassword) < 8 {
		graphql.AddError(ctx, &gqlerror.Error{
			Message: "Password must be at least 8 characters long",
			Extensions: map[string]interface{}{
				"code": "INVALID_INPUT",
			},
		})
		return false, errors.New("password too short")
	}

	// Get user from database
	dbUser, err := auth.GetUserByID(ctx, r.DB, authUser.ID)
	if err != nil {
		return false, err
	}

	// Verify old password
	valid, err := auth.VerifyPassword(oldPassword, dbUser.PasswordHash)
	if err != nil {
		return false, err
	}

	if !valid {
		graphql.AddError(ctx, &gqlerror.Error{
			Message: "Current password is incorrect",
			Extensions: map[string]interface{}{
				"code": "UNAUTHENTICATED",
			},
		})
		return false, auth.ErrUnauthorized
	}

	// Hash new password
	passwordHash, err := auth.HashPassword(newPassword)
	if err != nil {
		return false, err
	}

	// Update password
	err = auth.UpdateUserPassword(ctx, r.DB, authUser.ID, passwordHash)
	if err != nil {
		return false, err
	}

	// Revoke all refresh tokens for security (force re-login)
	_ = auth.RevokeAllUserRefreshTokens(ctx, r.DB, authUser.ID)

	return true, nil
}

// Me is the resolver for the me field.
func (r *queryResolver) Me(ctx context.Context) (*model.User, error) {
	// Get user from context (set by auth middleware)
	authUser, err := auth.GetUserFromContext(ctx)
	if err != nil {
		return nil, auth.Unauthorized(ctx)
	}

	// Fetch full user details from database
	dbUser, err := auth.GetUserByID(ctx, r.DB, authUser.ID)
	if err != nil {
		return nil, err
	}

	// Extract firstName and lastName from database
	var firstName, lastName *string
	if dbUser.FirstName.Valid {
		firstName = &dbUser.FirstName.String
	}
	if dbUser.LastName.Valid {
		lastName = &dbUser.LastName.String
	}

	return &model.User{
		ID:            dbUser.ID,
		Email:         dbUser.Email,
		EmailVerified: auth.IsEmailVerified(dbUser.EmailVerifiedAt),
		FirstName:     firstName,
		LastName:      lastName,
	}, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
